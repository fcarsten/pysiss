.. examples:

Usage Examples
**************

Simple example use cases for cWavelets library. The code for these examples is given in the :file:`../examples/` folder.

**Actually** This isn't really cWavelet examples, just pulled from another library so I can remember how to write reStructuredText files.

.. example_1:

Reading existing data from standalone engine
============================================

This example shows how to use the data parser class `Reader` (in `pymelts.readers`) to read in an entire folder of MELTS data which has already been generated by the standalone solver. 

Reading in a folder which contains precalculated MELTS data is fairly straightforward::

    from pymelts.readers import Reader
    reader = Reader('data/komatiite')

Because reading and parsing the data can be fairly time-consuming, the `Reader` class implements a basic form of caching by writing the initialised `Reader` instance out in binary format into the folder (in a file called `<folder_name>.pkl`). On subsequent reads of the folder, the `Reader` class checks for a pickled version of the data & loads it directly if it's there.

PyMELTS isn't very smart about whether the data has changed or not however - in particular it won't check to see whether the MELTS data has changed between calls. You can force a refresh of the data (i.e. by reparsing it) by passing `force=True` when you initialise a reader instance. This will overwrite the existing binary file with the new data::

    # This forces a re-parse of the data
    reader_new = Reader('data/komatiite', force=True)

The data is read into a variety of attributes in the returned Reader instance:

- `Reader.folder` - the location of the MELTS output folder.

- `Reader.files` - a dictionary containing the files which Reader has identified in the folder. This can be useful if you want to make sure that it is identifying the correct output files.

- `Reader.config_data` - a dictionary containing the information about the MELTS parameters used to drive the MELTS simulation.

- `Reader.system_data` - a dictionary containing the information about the extensive system variables (temperature, pressure, fugacities etc). Note that temperature is specified in Kelvin; use the celsius function from pymelts.utilities to change this to degrees Celsius.

- `Reader.phases` - contains a list of major phases in the magma

- `Reader.endmembers` - contains a dictionary of the phases present in the MELTS simulation, where each key is a phase and each value is a list of the endmember phases for that phase

- `Reader.phase_data` - contains the data from MELTS for a given phase. This attribute is a dictionary whose keys are given by Reader. phases, and whose values are dictionaries which contain physical properties (e.g. density, specific heat, viscosity) and proportions of endmember phases.

Plotting Melts data
-------------------

We can choose some of these variables to plot. In this case the data has been generated for varying temperature from 2000 to 500 degrees Celsius for a komatiitic composition. We're going to plot the mass, specific heat and density of the phases present in the komatiite as a function of temperature. We begin by specifying some of the variables we want to use::

    # Specify the variables to plot and some labels for axes
    x_variable = 'temperature'
    y_variables = ['mass', 'specific heat', 'density']

and some axes labels for the axes while we're at it::

    x_axis_label = r'Temperature ($^{\circ}\mathrm{C}$)'
    y_variable_labels = dict(zip(y_variables, [
        r'Mass ($m$, $g$)', 
        r'Specific heat ($c_{p}$, J kg$^{-1}$ K$^{-1}$)', 
        r'Density ($\rho$, kg m$^{-3}$) ']))

By defining `y_variable_labels` as a dictionary we will be able to loop over the y_variables when we plot and pull out the labels as needed (e.g. ``labels = [y_variable_labels[yvar] for yvar in y_variables]``). The phases which we want to loop over are already defined in the `Reader.phases` attribute.

Now that we've set up the basics, we just need to set up the matplotlib figure and axes::
    
    import matplotlib.pyplot as plt
    from pymelts.utilities import cycle_cmap
    nrows, ncols = len(y_variables), 1
    fig = plt.figure(figsize=(6, 3*nrows))
    cmap = cycle_cmap('Spectral', len(reader.phases))

The cycle_cmap function just generates a color cycle from a colormap, and makes it easier to change the color cycle that matplotlib uses to pick colors for it's lines (I find the defaults a bit ugly but YMMV).

and loop over the y variables, plotting the result for each phase, adding a legend and labelling the y axis using the labels defined above::

    for nax, y_variable in enumerate(y_variables):
        axs = plt.subplot(nrows, ncols, nax+1)
        axs.set_color_cycle(cmap)
        for phase in reader.phases:
            axs.plot(
                celsius(reader.phase_data[phase][x_variable]),
                reader.phase_data[phase][y_variable],
                label=phase)
            if nax == 0:
                axs.legend(loc='best', prop={"size":10})
            axs.set_ylabel(y_variable_labels[y_variable])

You can see that using the Reader instance's attributes it's fairly easy to iterate over the data which are available in the in a composition/magma agnostic fashion.

Then all we need to do is tidy up the labels and add a title::

    # Add an x axis label on the bottom plot only
    axs.set_xlabel(x_axis_label)
    fig.suptitle('Physical Properties of Phases in Komatiite' + 
        '\n(as calculated by MELTS)')

and the result is the following plot

.. image:: .static/komatiite.png
    :align: center

Calling the MELTS engine directly
=================================

The core of PyMELTS is the `pymelts.Engine` class. 

The reason that you have to call the engine class is that the MELTS library maintains state between calls. We realise that this isn't very Pythonic - and hope to rectify this issue at a later date.